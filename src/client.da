import sys
import da
from util import Request
import logging
import logging.config
import logging.handlers
import queue
import random
import time
import collections
import uuid


class Client(process):
    def setup(coordinators, config, num):
        '''
            Client setup. Generates a sequence of request and puts into a
            queue.
        '''
        self.logger = logging.getLogger('Log.' + __name__)
        self.size = len(coordinators)
        self.requestQueue = queue.Queue()
        self.exit = False
        self.defReadAttrMap = collections.defaultdict(dict)
        self.mightReadAttrMap = collections.defaultdict(dict)
        self.mightWriteObjectMap = collections.defaultdict(dict)

        sequenceList = []
        sequence = config.get("client" + str(num), "sequence")
        if (sequence == "random"):
            sequenceList = getRandomsequenceList(config, "client" + str(num))
        else:
            sequenceList = sequence.split(',')

        for seq in sequenceList:
            requestQueue.put([int(config.get(seq, "objectX")),
                              int(config.get(seq, "objectY")),
                              config.get(seq, "action")])
        # Mark the end of queue
        requestQueue.put(None)

    def getRandomsequenceList(config, client):
        '''
            If sequence is defined as random in config file then
            generate the random sequence using the seed given
        '''
        numReq = int(config.get(client, "numReq"))
        requestList = config.get(client, "requestList").split(',')
        random.seed(int(config.get(client, "seed")))
        sequenceList = []

        for _ in range(0, numReq):
            randInt = random.randint(0, len(requestList) - 1)
            sequenceList.append(requestList[randInt])

        return sequenceList

    def sendToSubjectCoordinator():
        elem = requestQueue.get()
        if (elem == None):
            self.exit = True
            return

        coordID = (elem[0]) % self.size
        objectX = elem[0]
        objectY = elem[1]
        objectSwap = False
        isReadOnly = True
        defReadAttrX = []
        defReadAttrY = []
        mightReadAttrX = []
        mightReadAttrY = []

        print(coordID)
        print(coordinators[coordID])
        logger.info("Client %d sending Request{Subject ID: %d, Resource ID: "
                    "%d, action: %s} to coordinator %d", self.num, elem[0],
                    elem[1], elem[2], coordID)

        requestID = uuid.uuid4()

        if elem[2] in self.mightWriteObjectMap:
            if elem[1] in self.mightWriteObjectMap[elem[2]]:
                coordID = (elem[1]) % self.size
                objectX = elem[1]
                objectY = elem[0]
                isReadOnly = False
                objectSwap = True
            elif elem[0] in self.mightWriteObjectMap[elem[2]]:
                isReadOnly = False

        if elem[2] in self.defReadAttrMap:
            if objectX in self.defReadAttrMap[elem[2]]:
                defReadAttrX = self.defReadAttrMap[elem[2]][objectX]
            if objectY in self.defReadAttrMap[elem[2]]:
                defReadAttrY = self.defReadAttrMap[elem[2]][objectY]
            if objectX in self.mightReadAttrMap[elem[2]]:
                mightReadAttrX = self.mightReadAttrMap[elem[2]][objectX]
            if objectY in self.mightReadAttrMap[elem[2]]:
                mightReadAttrY = self.mightReadAttrMap[elem[2]][objectY]

        request = Request(requestID, objectX, objectY, elem[2], True,
                          isReadOnly, defReadAttrX, defReadAttrY,
                          mightReadAttrX, mightReadAttrY, objectSwap)
        print(request)

        send(('EVALUATE', request), to=coordinators[coordID])
        # start timer
        # if timeout rescedule

    def staticAnalysis():
        self.defReadAttrMap["read"]["person"] = ["position", "history"]
        self.defReadAttrMap["read"]["bank"] = ["id"]
        self.defReadAttrMap["view"]["person"] = ["position"]
        self.defReadAttrMap["view"]["movie"] = ["viewCount"]
        self.mightReadAttrMap["read"]["bank"] = ["account"]
        self.mightWriteObjectMap["view"]["movie"] = True
        self.mightWriteObjectMap["read"]["person"] = True

    def receive(msg=('RESULT_CLIENT', response)):
        # stop timer
        if response.decision:
            print("YES")
        # logger.info("Allow access to client %d for Request{Subject ID: "
        #                         "%d, Resource ID: %d, action: %s}", self.num, subjectID,
        #                         resourceID, action)
        else:
            pass
        # logger.info("Deny access to client %d for Request{Subject ID: "
        #                         "%d, Resource ID: %d, action: %s}", self.num, subjectID,
        #                         resourceID, action)

        sendToSubjectCoordinator()

    def run():
        logger.info("Started Client %d", self.num)
        sendToSubjectCoordinator()
        await(self.exit == True)
