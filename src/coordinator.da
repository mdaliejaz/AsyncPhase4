import sys
import da
import uuid
import worker
import time
import queue
import logging
import logging.config
import logging.handlers
from util import Request
from collections import deque


class Version(object):
    def __init__(self):
        self.rts = 0
        self.wts = 0
        self.pendingMightRead = []  # tuple (requestID, req.ts)
        self.value = None

    def __str__(self):
        return "\n\trts = {}" \
               "\n\twts = {}" \
               "\n\tpendingMightRead = {}" \
               "\n\tvalue = {}".format(self.rts, self.wts,
                                       self.pendingMightRead, self.value)


class Coordinator(process):
    def setup(coordinators, dbInstance, config):
        '''
            Coordinator setup. Setup and start the workers.
            Initialize maps and other data structures.
        '''
        self.logger = logging.getLogger('Log.' + __name__)

        # new parameters for phase4
        self.versionCache = {}
        self.size = len(coordinators)
        self.coordSessionID = uuid.uuid4()  # Session id for co-ordinator
        self.PCA = {}  # To handle starvation of write requests

        self.coordinators = coordinators

        self.nworkerspercoord = int(config.get("setup", "nworkerspercoord"))
        self.workers = new(worker.Worker, num=self.nworkerspercoord)
        self.workerList = list(self.workers)
        self.workerSequence = -1
        setup(self.workers, (self.coordinators, dbInstance, config,))
        start(self.workers)

    def latestVersionBefore(objID, attr, ts):
        if objID not in self.versionCache:
            self.versionCache[objID] = {}
        if attr not in self.versionCache[objID]:
            self.versionCache[objID][attr] = []

        for v in reversed(self.versionCache[objID][attr]):
            if v.wts < ts:
                return v

        v = Version()
        self.versionCache[objID][attr].append(v)

        return v

    def getCachedUpdates(request, obj):
        res = {}
        if obj == "X":
            for attr in list(
                    set().union(request.defReadAttrX, request.mightReadAttrX)):
                v = latestVersionBefore(request.objectX, attr, request.ts)
                if v.wts != 0:
                    res[attr] = v.value
        else:
            for attr in list(
                    set().union(request.defReadAttrY, request.mightReadAttrY)):
                v = latestVersionBefore(request.objectY, attr, request.ts)
                if v.wts != 0:
                    res[attr] = v.value
        return res

    def checkPCA(request, obj):
        if obj == "X":
            try:
                for attr in list(
                        set().union(request.defReadAttrX, request.mightReadAttrX)):
                    if len(self.PCA[request.objectX][attr]) > 0:
                        return True
            except:
                pass
            return False
        else:
            try:
                for attr in list(
                        set().union(request.defReadAttrY, request.mightReadAttrY)):
                    if len(self.PCA[request.objectY][attr]) > 0:
                        return True
            except:
                pass
            return False

    def receive(msg=("EVALUATE_2", request, swap), from_=p):
        '''
            Subject coordinator instance, receives from client / another coord
        '''
        logger.info("Request received from coord:\n%s", request)
        
        if request.isReadOnly == True:
                
            if swap == True:
            
                for attr in request.defReadAttrY:
                    latestVersionBefore(request.objectY, attr,
                                        request.ts).rts = request.ts

                for attr in request.mightReadAttrY:
                    v = latestVersionBefore(request.objectY, attr,
                                        request.ts)
                    v.pendingMightRead.append(
                        (request.requestID, request.ts))
                    # print(attr, v)
            else:
                
                for attr in request.defReadAttrX:
                    latestVersionBefore(request.objectX, attr,
                                        request.ts).rts = request.ts

                for attr in request.mightReadAttrX:
                    v = latestVersionBefore(request.objectX, attr,
                                        request.ts)
                    v.pendingMightRead.append(
                        (request.requestID, request.ts))  
                    # print(attr, v)                  
                                    
                                        
        else:
            if swap == True:
                for attr in list(
                        set().union(request.defReadAttrY,
                                    request.mightReadAttrY)):
                    latestVersionBefore(request.objectY, attr,
                                        request.ts).pendingMightRead.append(
                        (request.requestID, request.ts))
            else:
                 for attr in list(
                        set().union(request.defReadAttrX,
                                    request.mightReadAttrX)):
                    latestVersionBefore(request.objectX, attr,
                                        request.ts).pendingMightRead.append(
                        (request.requestID, request.ts))                   
                                     
            if swap == True:
                request.cachedUpdatesY = getCachedUpdates(request, "Y")
            else:
                request.cachedUpdatesX = getCachedUpdates(request, "Y")
        
        workerSequence = (workerSequence + 1) % len(workerList)
        send(('WORKER_ASSIGN', request), to=workerList[workerSequence])


    def receive(msg=("EVALUATE", request), from_=p):
        '''
            Subject coordinator instance, receives from client / another coord
        '''
        logger.info("Request received from client:\n%s", request)
        if request.objectSwap == True:
            await(checkPCA(request, "Y") == False)
                    
            if request.objectY not in PCA:
                PCA[request.objectY] = {}
            
            for key in request.mightWriteAttrY:
                if key not in PCA[request.objectY]:
                    PCA[request.objectY][key] = []
            
                PCA[request.objectY][key].append(request.requestID)
            
        else:
            await(checkPCA(request, "X") == False)
            if request.objectX not in PCA:
                PCA[request.objectX] = {}
            
            for key in request.mightWriteAttrX:
                if key not in PCA[request.objectX]:
                    PCA[request.objectX][key] = []
        
                PCA[request.objectX][key].append(request.requestID)
            
        # request.sessionIdX = self.coordSessionID
        request.fromClient = p
        request.ts = time.time()
        
        if request.isReadOnly == True:
            
            if request.objectSwap == True:
            
                for attr in request.defReadAttrY:
                    latestVersionBefore(request.objectY, attr,
                                        request.ts).rts = request.ts

                for attr in request.mightReadAttrY:
                    v = latestVersionBefore(request.objectY, attr,
                                        request.ts)
                    v.pendingMightRead.append(
                        (request.requestID, request.ts))
                    # print(attr, v)
            else:
                
                for attr in request.defReadAttrX:
                    latestVersionBefore(request.objectX, attr,
                                        request.ts).rts = request.ts

                for attr in request.mightReadAttrX:
                    v = latestVersionBefore(request.objectX, attr,
                                        request.ts)
                    v.pendingMightRead.append(
                        (request.requestID, request.ts))
                    # print(attr, v)
                                    
                                    
        else:
            if request.objectSwap == True:
                for attr in list(
                        set().union(request.defReadAttrY,
                                    request.mightReadAttrY)):
                    v = latestVersionBefore(request.objectY, attr,
                                        request.ts)
                    v.pendingMightRead.append(
                        (request.requestID, request.ts))
                    # print(attr, v)
            else:
                 for attr in list(
                        set().union(request.defReadAttrX,
                                    request.mightReadAttrX)):
                    v = latestVersionBefore(request.objectX, attr,
                                        request.ts)
                    v.pendingMightRead.append(
                        (request.requestID, request.ts))  
                    # print(attr, v)

        if request.objectSwap == True:
            request.cachedUpdatesY = getCachedUpdates(request, "Y")
        else:
            request.cachedUpdatesX = getCachedUpdates(request, "X")
        
        if request.objectSwap == True:
            send(('EVALUATE_2', request, not(request.objectSwap) ),
                 to=coordinators[request.objectX % len(coordinators)])
        else:
            send(('EVALUATE_2', request, not(request.objectSwap)),
                 to=coordinators[request.objectY % len(coordinators)])       
                
                      
        
    def receive(msg=('SENDATTR', request, obj), from_=p):
        # if getattr(request, "sessionId" + obj) != self.coordSessionID:
        #    return  # To check
        # # Implementation #TODO

        if obj == "X":
            for attr in request.mightReadAttrX:
                v = latestVersionBefore(request.objectX, attr, request.ts)
                pendingMightRead = [i for i in v.pendingMightRead if
                                    i[0] != request.requestID]
                v.pendingMightRead = pendingMightRead
                # print(attr, v)
                if attr in request.readAttrX:
                    v.rts = request.ts
                    
            # Remove from PCA
            if request.isReadOnly == False:
                for k in request.mightWriteAttrX:
                    PCA[request.objectX][k].remove(request.requestID)
        else:
            for attr in request.mightReadAttrY:
                v = latestVersionBefore(request.objectY, attr, request.ts)
                pendingMightRead = [i for i in v.pendingMightRead if
                                    i[0] != request.requestID]
                v.pendingMightRead = pendingMightRead
                # print(attr, v)
                if attr in request.readAttrY:
                    v.rts = request.ts
                
            # Remove from PCA    
            if request.isReadOnly == False:
                for k in request.mightWriteAttrY:
                    PCA[request.objectY][k].remove(request.requestID)


    def readAwaitCheck(objID, updates, ts, reqID):
        for k, _ in updates.items():
            v = latestVersionBefore(objID, k, ts)
            if len(v.pendingMightRead) == 0 or (
                            len(v.pendingMightRead) == 1 and
                            v.pendingMightRead[0][
                                0] == reqID):
                pass
            else:
                return False
        return True

    def updateCache(objID, response):
        for k, v in response.updates.items():
            ver = Version()
            if objID not in self.versionCache:
                self.versionCache[objID] = {}

            if k not in self.versionCache[objID]:
                self.versionCache[objID][k] = []
            else:
                ver.wts = response.request.ts

            ver.value = v
            self.versionCache[objID][k].append(ver)

    def receive(msg=('RESULT', response, objID), from_=worker):
        logger.info("Result received from worker for request:\n%s",
                    response.request)
        rID = None
        if response.request.objectX == objID:
            rID = "Y"
            obj = "X"
        else:
            rID = "X"
            obj = "Y"

        # if getattr(response.request, "sessionId" + obj) != self.coordSessionID:
        #    return  # Check # Important # To implement #TODO

        conflict = checkConflicts(response)

        if not conflict:

            # await for all pending reads
            print("response.updates", response.updates)
            await(readAwaitCheck(objID, response.updates, response.request.ts,
                                 response.request.requestID) == True)

            conflict = checkConflicts(response)

            if not conflict:
                updateCache(objID, response)

                # commit the updates
                send(("COMMIT_TO_DB", response), to=dbInstance)

                # Update read timestamps
                if objID == response.request.objectX:
                    defreadAttrs = getattr(response.request, "defReadAttrX")
                    mightReadAttrs = getattr(response.request,
                                             "mightReadAttrX")
                    readAttr = getattr(response.request, "readAttrX")

                else:
                    defreadAttrs = getattr(response.request, "defReadAttrY")
                    mightReadAttrs = getattr(response.request,
                                             "mightReadAttrY")
                    readAttr = getattr(response.request, "readAttrY")

                for attr in list(set().union(defreadAttrs, mightReadAttrs)):
                    v = latestVersionBefore(objID, attr,
                                            response.request.ts)

                    pendingMightRead = [i for i in v.pendingMightRead if
                                        i[0] != response.request.requestID]
                    v.pendingMightRead = pendingMightRead

                    if attr in readAttr:
                        v.rts = response.request.ts

                send(("RESULT_CLIENT", response),
                     to=response.request.fromClient)
                # update read timestamps.
                send(("SENDATTR", response.request, rID),
                     to=coordinators[getattr(response.request, "object" +
                                             rID) % size])

            else:
                # restart
                coordID = None
                if objID == response.request.objectX:
                    coordID = response.request.objectY % len(self.coordinators)
                else:
                    coordID = response.request.objectX % len(self.coordinators)
                send(('EVALUATE', response.request), to=coordinators[coordID])
        else:
            # restart
            coordID = None
            if objID == response.request.objectX:
                coordID = response.request.objectY % len(self.coordinators)
            else:
                coordID = response.request.objectX % len(self.coordinators)
            send(('EVALUATE', response.request), to=coordinators[coordID])

    def checkConflicts(resp):
        for attr, val in resp.updates.items():
            v = latestVersionBefore(resp.request.objectX, attr, resp.request.ts)
            if v.rts > resp.request.ts:
                return True
            return False

    def run():
        logger.info("Starting Coordinator with %d workers",
                    self.nworkerspercoord)
        await(received(('done',)))
        send(('done',), to=(self.workers))
